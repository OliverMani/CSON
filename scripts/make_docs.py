# This is a helper to update README.md

from sys import argv
import os
import re

__INCLUDE__ = os.path.join('..', 'include')
__README__ = os.path.join('..', 'README.md')

HARD_CODED_DOCUMENTATION = """# CSON
## Another JSON library in C!
(Introduction missing!)
### How to set up (the test)

1. Download the source code
2. Make sure you have CMake and Make installed
3. Open up terminal and change directory to the same directory as you find CMakeLists.txt
4. Run `cmake .` to generate Makefile
5. Run `make` to create the executable
6. Now, you can run the small generated test (which is main.c), by running `./myexecutable`
7. And finally, do whatever you want with this code/library I coded :)

### Documentation of what the library has to offer!
The following documentation is generated by the `make_docs.py` script in the script directory, enjoy!

"""

REGULAR_EXPRESSIONS = \
    {
        'enum': r'\s*(enum)\s+(\w\S*)\s*(\{.*\})?\s*;\s*',
        'typedef': r'\s*(typedef)\s+([\w\s]+)\s+([^;]+);\s*',
        'function': r'\s*(\w.*)\s+(\w\S*)\s*\((.*)\)\s*;\s*'
    }

class Thing:
    def __init__(self, kind, name, documentation):
        self.kind = kind
        self.name = name
        self.documentation = documentation
    
class Function(Thing):
    def __init__(self, kind, name, args, documentation):
        super().__init__(kind, name, documentation)
        self.args = args

def convert_documentaion():
    pass

def parse_line(line, documentation):
    line = line.strip()
    for key, value in REGULAR_EXPRESSIONS.items():
        match = re.search(value, line)
        if match is not None:
            kind = match.group(0)
            if key == 'function':
                return Function(match.group(1), match.group(2), match.group(3), documentation)
            if key == 'typedef':
                return Thing(match.group(1), match.group(2), documentation)
            if key == 'enum':
                #print("ENUM:", match.group(0))
                return Thing('enum', match.group(2), documentation)
    return None


def parse_header_file(code):
    lines = code.split('\n')
    reading_comment = False
    last_comment = ''

    objects = [] # Functions, structs and more put into a list

    for line in lines:
        if not reading_comment and line.strip().replace(' ', '').startswith('/**'):
            reading_comment = True
        elif reading_comment and line.strip().replace(' ', '').endswith('*/'):
            reading_comment = False
        else:
            if reading_comment:
                if line.startswith(' *'):
                    line = line[2:]
                last_comment += line.strip() + '\n'
            else:
                
                code_object = parse_line(line, last_comment)
                if code_object is not None:
                    objects.append(code_object)
                last_comment = ''
    return objects

def leftfix(string, length):
    return string + (' ' * (length - len(string)))

def generate_readme(filename, objects):
    length = 100
    readme = f'#### #include <cson/{filename}>\n'
    readme += f'| {leftfix("Function or type", length)} | {leftfix("Info",length)} |\n'
    readme += f'|:{"-"*length}-|:{"-"*length}-|\n'
    for obj in objects:
        if type(obj) == Function:
            #readme += f'```C\n\t{obj.kind} {obj.name} ({obj.args})\n\t```'
            tmpfunc = f'`{obj.kind} {obj.name} ({obj.args})`'
            readme += f'| {leftfix(tmpfunc, length)} |'
        else:
            readme += f'| {leftfix(obj.kind, length)} {leftfix(obj.name, length)}'
        if obj.documentation != '':
            #joined = "\n   ".join(n.split("\n"))
            readme += f'```{leftfix(obj.documentation, length)}``` |\n'
        else:
            readme += f'| {leftfix(" " * length)} |\n'
    return readme

def main(args):
    #print(HARD_CODED_DOCUMENTATION)
    with open(__README__, 'w') as write:
        write.write(HARD_CODED_DOCUMENTATION)
        for dirpath, dirnames, filenames in os.walk(__INCLUDE__):
            for filename in filenames:
                path = os.path.join(dirpath, filename)
                with open(path, 'r') as file:
                    code = file.read()
                    objects = parse_header_file(code)
                    write.write(generate_readme(filename, objects))
                    #print(generate_readme(filename, objects))
                    #print()
    print("Successfully generated docs!")

if __name__ == '__main__':
    main(argv[1:])